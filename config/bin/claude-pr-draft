#!/usr/bin/env bash
#
# claude-pr-draft - PR body draft management tool for Claude Code
#
# This command is designed to be used by Claude Code to create and manage
# PR body drafts with user review via Neovim in a new Wezterm window.
#
# See also: config/claude/commands/create-pr.md
# (When modifying this script, update the command file as well)
#
# Usage:
#   claude-pr-draft new [--title "PR title"]
#   claude-pr-draft review <filepath>
#   claude-pr-draft submit <filepath> [gh pr create options...]
#
set -euo pipefail

# Show help
show_help() {
  cat << EOF
PR body draft management tool for Claude Code

Usage: claude-pr-draft [--help] <command> [args]

Commands:
  new [--title "title"]        Create a new temporary draft file and output its path
                               Accepts content from stdin if provided
  review <filepath>            Open the draft file in Neovim (new Wezterm window)
  submit <filepath> [options]  Create PR with the draft file as body

Draft File Format:
  The draft file uses YAML frontmatter to control PR creation:

  # For private repos:
  ---
  title: "PR title here"
  steps:
    submit: false
  ---

  # For public repos:
  ---
  title: "PR title here"
  steps:
    ready-for-translation: false
    submit: false
  ---

  PR body content here...

  Frontmatter fields:
    title                       - PR title (required for submit)
    steps.ready-for-translation - (public repos only) Set to true when draft is approved
                                  Claude translates when this is true AND body contains Japanese
    steps.submit                - Set to true to approve; file hash is saved on editor exit
                                  Any modification after approval invalidates the hash

Examples:
  # Create a new draft file with title and content from stdin
  echo "PR body content..." | claude-pr-draft new --title "Add new feature"

  # Open draft file for user review
  claude-pr-draft review /tmp/pr-body-draft.xxx.md

  # Create PR after user approval (title is taken from frontmatter)
  claude-pr-draft submit /tmp/pr-body-draft.xxx.md --base main
EOF
}

# Parse options
while [[ $# -gt 0 ]]; do
  case "$1" in
    -h | --help)
      show_help
      exit 0
      ;;
    -*)
      echo "Error: Unknown option: $1" >&2
      echo "Run 'claude-pr-draft --help' for usage information" >&2
      exit 1
      ;;
    *)
      # First non-option argument is the subcommand
      break
      ;;
  esac
done

# Parse command line arguments
SUBCOMMAND="${1:-}"
shift || true

# Check if current repository is public
is_public_repo() {
  local visibility
  visibility=$(gh repo view --json isPrivate -q '.isPrivate' 2> /dev/null)
  [[ "$visibility" == "false" ]]
}

# Get current repository name (owner/repo format)
get_repo_name() {
  gh repo view --json nameWithOwner -q '.nameWithOwner' 2> /dev/null || echo "unknown"
}

# Get current branch name
get_branch_name() {
  git branch --show-current 2> /dev/null || echo "unknown"
}

# Create a new temporary draft file
new_draft() {
  local title=""

  # Parse options for new subcommand
  while [[ $# -gt 0 ]]; do
    case "$1" in
      --title)
        if [[ $# -lt 2 ]]; then
          echo "Error: --title requires a value" >&2
          exit 1
        fi
        title="$2"
        shift 2
        ;;
      *)
        echo "Error: Unknown option for 'new': $1" >&2
        exit 1
        ;;
    esac
  done

  local draft_file
  draft_file=$(mktemp /tmp/pr-body-draft.XXXXXX.md)

  # Write YAML frontmatter template based on repo visibility
  if is_public_repo; then
    cat > "$draft_file" << FRONTMATTER
---
title: "${title}"
steps:
  ready-for-translation: false
  submit: false
---

FRONTMATTER
  else
    cat > "$draft_file" << FRONTMATTER
---
title: "${title}"
steps:
  submit: false
---

FRONTMATTER
  fi

  # If stdin is available, append content from stdin
  if [ ! -t 0 ]; then
    cat >> "$draft_file"
  fi

  echo "$draft_file"
}

# Calculate hash of file content
calc_file_hash() {
  local filepath="$1"
  shasum -a 256 "$filepath" | cut -d' ' -f1
}

# Review draft in Neovim (new Wezterm window)
review_draft() {
  local filepath="$1"
  local lock_file="${filepath}.lock"
  local approve_file="${filepath}.approve"

  if [[ ! -f "$filepath" ]]; then
    echo "Error: File not found: $filepath" >&2
    exit 1
  fi

  # Skip if Neovim is already open for this file.
  # This prevents launching multiple editor windows when `review` is called
  # multiple times for the same file (e.g., Claude retrying the command).
  # The lock file is created before launching Neovim and removed when it exits.
  if [[ -f "$lock_file" ]]; then
    echo "Skipped: Neovim is already open for this file (lock file exists: $lock_file)" >&2
    return 0
  fi

  # Capture current tmux session/window/pane and client to return after review
  local original_tmux_target=""
  local original_tmux_client=""
  if [[ -n "${TMUX:-}" ]]; then
    original_tmux_target=$(tmux display-message -p '#{session_name}:#{window_index}.#{pane_index}')
    original_tmux_client=$(tmux display-message -p '#{client_tty}')
  fi

  # Create a wrapper script that handles approval after Neovim exits
  local wrapper_script
  wrapper_script=$(mktemp /tmp/nvim-wrapper.XXXXXX.sh)
  cat > "$wrapper_script" << 'WRAPPER_EOF'
#!/usr/bin/env bash
set -euo pipefail

filepath="$1"
original_tmux_target="$2"
original_tmux_client="$3"
window_title="$4"
lock_file="${filepath}.lock"
approve_file="${filepath}.approve"

# Set window title via Neovim's titlestring option (no config file changes needed)
# Use let &titlestring to properly handle special characters
nvim -c "let &titlestring = '$window_title'" "$filepath"

# Check steps.submit value in frontmatter
submit=$(sed -n '2,/^---$/p' "$filepath" | sed '$d' | yq -r '.steps.submit // "false"')

if [[ "$submit" == "true" ]]; then
  # Save hash of file content for verification
  shasum -a 256 "$filepath" | cut -d' ' -f1 > "$approve_file"
  echo "Approved. Hash saved."
else
  # Remove approve file if exists (rejected)
  rm -f "$approve_file"
  echo "Not ready for submit."
fi

# Remove lock file (Neovim is closed)
rm -f "$lock_file"

# Switch back to original tmux session/window/pane
if [[ -n "$original_tmux_target" && -n "$original_tmux_client" ]]; then
  # Switch the original client to the target session:window.pane
  tmux switch-client -c "$original_tmux_client" -t "$original_tmux_target" 2>/dev/null || true
fi
WRAPPER_EOF
  chmod +x "$wrapper_script"

  # Mark as currently being reviewed
  touch "$lock_file"

  # Get repo and branch for window title
  local repo branch window_title
  repo=$(get_repo_name)
  branch=$(get_branch_name)
  window_title="PR: ${repo:-unknown} @ ${branch:-unknown}"

  # Use macOS open command to properly launch WezTerm as a GUI app
  # -n: Open a new instance even if WezTerm is already running
  # This ensures the window is focused and appears in app switchers (including AltTab)
  # --config: Show title bar for this window only
  # Window title is set via OSC escape sequence in the wrapper script
  open -n -a WezTerm --args \
    --config 'window_decorations="TITLE | RESIZE"' \
    start -- "$wrapper_script" "$filepath" "$original_tmux_target" "$original_tmux_client" "$window_title"
}

# Extract YAML frontmatter as raw YAML
get_frontmatter() {
  local filepath="$1"
  sed -n '2,/^---$/p' "$filepath" | sed '$d'
}

# Extract YAML frontmatter value by key using yq
# Usage: get_frontmatter_value <filepath> <key>
get_frontmatter_value() {
  local filepath="$1"
  local key="$2"
  get_frontmatter "$filepath" | yq -r ".$key // \"\""
}

# Extract body content (everything after frontmatter)
get_body_content() {
  local filepath="$1"
  # BSD sed: '1,/^---$/d' deletes from line 1 to the first line matching ^---$
  # after line 1 (i.e., the closing ---), so one sed is enough
  sed '1,/^---$/d' "$filepath"
}

# Check if text contains Japanese characters
contains_japanese() {
  local text="$1"
  # Use Perl for proper Unicode property support (grep doesn't support \p{...})
  ! echo "$text" | perl -CSD -ne 'exit 1 if /[\p{Hiragana}\p{Katakana}\p{Han}]/'
}

# Submit PR with draft file as body
submit_pr() {
  local filepath="$1"
  local lock_file="${filepath}.lock"
  local approve_file="${filepath}.approve"
  shift

  if [[ ! -f "$filepath" ]]; then
    echo "Error: File not found: $filepath" >&2
    exit 1
  fi

  # Check if Neovim is still open
  if [[ -f "$lock_file" ]]; then
    echo "Error: Please close the editor before submitting the PR." >&2
    exit 1
  fi

  # Check if approve file exists (rejected if not)
  if [[ ! -f "$approve_file" ]]; then
    echo "Error: PR was not approved. Please run 'review' and set 'steps.submit: true'." >&2
    exit 1
  fi

  # Verify hash matches (detect tampering after approval)
  local saved_hash current_hash
  saved_hash=$(cat "$approve_file")
  current_hash=$(calc_file_hash "$filepath")

  if [[ "$saved_hash" != "$current_hash" ]]; then
    echo "Error: File has been modified after approval. Please run 'review' again." >&2
    exit 1
  fi

  # Parse frontmatter
  local title has_translation_step
  title=$(get_frontmatter_value "$filepath" "title")
  # Check if steps.ready-for-translation key exists (public repo)
  has_translation_step=$(get_frontmatter "$filepath" | yq -r 'has("steps") and .steps | has("ready-for-translation")')

  # Validate title is not empty
  if [[ -z "$title" ]]; then
    echo "Error: Please set a title in the frontmatter." >&2
    exit 1
  fi

  # Check for Japanese characters if steps.ready-for-translation exists (public repo)
  if [[ "$has_translation_step" == "true" ]]; then
    local body
    body=$(get_body_content "$filepath")

    if contains_japanese "$title"; then
      echo "Error: Title contains Japanese characters but this is a public repo." >&2
      echo "Please translate the title to English." >&2
      exit 1
    fi

    if contains_japanese "$body"; then
      echo "Error: Body contains Japanese characters but this is a public repo." >&2
      echo "Please translate the body to English." >&2
      exit 1
    fi
  fi

  # Create temporary file with body content only (without frontmatter)
  local body_file
  body_file=$(mktemp /tmp/pr-body.XXXXXX.md)
  get_body_content "$filepath" > "$body_file"

  # Pass remaining arguments to gh pr create
  local pr_url
  pr_url=$(gh pr create --title "$title" --body-file "$body_file" "$@")

  # Clean up temporary files
  rm -f "$body_file"
  rm -f "$filepath" "$lock_file" "$approve_file"

  echo "$pr_url"

  # Open PR in browser
  gh pr view --web "$pr_url"
}

# Main execution
case "$SUBCOMMAND" in
  new)
    new_draft "$@"
    ;;
  review)
    if [[ $# -ne 1 ]]; then
      echo "Error: review requires exactly 1 argument: <filepath>" >&2
      exit 1
    fi
    review_draft "$1"
    ;;
  submit)
    if [[ $# -lt 1 ]]; then
      echo "Error: submit requires at least 1 argument: <filepath> [gh pr create options...]" >&2
      exit 1
    fi
    submit_pr "$@"
    ;;
  "")
    echo "Error: No command specified" >&2
    echo "Run 'claude-pr-draft --help' for usage information" >&2
    exit 1
    ;;
  *)
    echo "Error: Unknown command: $SUBCOMMAND" >&2
    echo "Run 'claude-pr-draft --help' for usage information" >&2
    exit 1
    ;;
esac
