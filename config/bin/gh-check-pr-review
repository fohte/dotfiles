#!/bin/bash
set -euo pipefail

# gh-check-pr-review: Fetch PR review comments in a concise format for LLM agents

print_diff() {
  local path="$1"
  local hunk_header="$2"
  {
    echo "diff --git a/$path b/$path"
    echo "--- a/$path"
    echo "+++ b/$path"
    echo "$hunk_header"
    cat
  } | delta --paging=never --line-numbers
}

# Collapse <details> blocks, keeping only <summary> content
collapse_details() {
  local text="$1"
  # Use perl for multiline regex replacement
  # Replace <details>...<summary>X</summary>...</details> with [▶ X]
  echo "$text" | perl -0777 -pe '
    s{<details[^>]*>\s*<summary[^>]*>(.*?)</summary>.*?</details>}{[▶ $1]}gs;
  '
}

show_help() {
  cat << EOF
gh-check-pr-review - Fetch PR review comments in a concise format

Usage:
  gh-check-pr-review <pr-number> [options]

Options:
  -R <owner/repo>   Target repository (default: current repo)
  -a, --all         Include resolved comments (default: only unresolved)
  -r, --review N    Show details for review number N (from summary)
  -f, --full        Show all details (original behavior)
  -d, --open-details  Expand <details> blocks (default: collapsed)
  -h, --help        Show this help

Output Modes:
  Default (summary):
    Shows review list with thread counts and first line of comments.
    Use this to get an overview before diving into details.

  --review N:
    Shows full details for a specific review (body + all threads).

  --full:
    Shows all reviews and threads with full details (original behavior).

Examples:
  gh-check-pr-review 123              # Summary view
  gh-check-pr-review 123 --review 1   # Details for review [1]
  gh-check-pr-review 123 --full       # Full details
  gh-check-pr-review 123 --all        # Include resolved threads
EOF
}

die() {
  echo "Error: $1" >&2
  exit 1
}

get_repo_from_arg_or_current() {
  local repo="$1"
  if [[ -n "$repo" ]]; then
    echo "$repo"
  else
    gh repo view --json nameWithOwner --jq '.nameWithOwner'
  fi
}

format_datetime() {
  local iso_date="$1"
  # Convert ISO 8601 to readable format
  if command -v gdate &> /dev/null; then
    gdate -d "$iso_date" '+%Y-%m-%d %H:%M'
  elif date --version &> /dev/null 2>&1; then
    date -d "$iso_date" '+%Y-%m-%d %H:%M'
  else
    # macOS date fallback
    echo "$iso_date" | sed 's/T/ /; s/Z//; s/\.[0-9]*//' | cut -c1-16
  fi
}

print_comment() {
  local comment="$1"
  local indent="$2"
  local is_reply="$3"
  local is_resolved="$4"

  local path author created_at diff_hunk body

  path=$(echo "$comment" | jq -r '.path')
  author=$(echo "$comment" | jq -r '.author.login // "unknown"')
  created_at=$(echo "$comment" | jq -r '.createdAt')
  diff_hunk=$(echo "$comment" | jq -r '.diffHunk // empty')
  body=$(echo "$comment" | jq -r '.body')

  # Collapse <details> blocks unless --open-details is specified
  if [[ "${OPEN_DETAILS:-false}" != "true" ]]; then
    body=$(collapse_details "$body")
  fi

  local formatted_date
  formatted_date=$(format_datetime "$created_at")

  # Print comment header with optional tree prefix
  # 48;5;238 = dark gray background
  if [[ "$is_reply" == "true" ]]; then
    printf '%s└─ \e[48;5;238m @%s (%s) \e[0m\n' "$indent" "$author" "$formatted_date"
  else
    # Build resolved indicator (dim text) for root comments only
    local resolved_indicator=""
    if [[ "$is_resolved" == "true" ]]; then
      resolved_indicator=" \e[2m[resolved]\e[0m"
    fi
    printf '\e[48;5;238m @%s (%s) \e[0m%b\n' "$author" "$formatted_date" "$resolved_indicator"
  fi

  # Print diff context (only for root comments)
  if [[ "$is_reply" != "true" && -n "$diff_hunk" ]]; then
    local hunk_header
    hunk_header=$(echo "$diff_hunk" | head -n 1)
    echo "$diff_hunk" | tail -n 3 | print_diff "$path" "$hunk_header"
  fi

  # Print comment body with glow (if available)
  # shellcheck disable=SC2001 # sed is needed for multiline prefix
  if command -v glow &> /dev/null; then
    if [[ "$is_reply" == "true" ]]; then
      echo "$body" | glow - 2> /dev/null | sed "s/^/${indent}   /"
    else
      echo "$body" | glow - 2> /dev/null
    fi
  else
    if [[ "$is_reply" == "true" ]]; then
      echo "$body" | sed "s/^/${indent}   /"
    else
      echo "$body"
    fi
  fi
  echo ""
}

print_review() {
  local review="$1"

  local author state created_at body

  author=$(echo "$review" | jq -r '.author.login // "unknown"')
  state=$(echo "$review" | jq -r '.state')
  created_at=$(echo "$review" | jq -r '.createdAt')
  body=$(echo "$review" | jq -r '.body')

  # Collapse <details> blocks unless --open-details is specified
  if [[ "${OPEN_DETAILS:-false}" != "true" ]]; then
    body=$(collapse_details "$body")
  fi

  local formatted_date
  formatted_date=$(format_datetime "$created_at")

  # Format state indicator
  local state_indicator
  case "$state" in
    APPROVED) state_indicator="\e[32m[approved]\e[0m" ;;
    CHANGES_REQUESTED) state_indicator="\e[31m[changes requested]\e[0m" ;;
    COMMENTED) state_indicator="\e[33m[commented]\e[0m" ;;
    DISMISSED) state_indicator="\e[2m[dismissed]\e[0m" ;;
    *) state_indicator="[$state]" ;;
  esac

  printf '\e[48;5;238m @%s (%s) \e[0m %b\n' "$author" "$formatted_date" "$state_indicator"

  # Print review body with glow (if available)
  if command -v glow &> /dev/null; then
    echo "$body" | glow - 2> /dev/null
  else
    echo "$body"
  fi
  echo ""
}

fetch_pr_data() {
  local owner="$1"
  local repo="$2"
  local pr_number="$3"
  local include_resolved="$4"

  # shellcheck disable=SC2016 # GraphQL variables use $ syntax intentionally
  local query='
query($owner: String!, $repo: String!, $pr: Int!, $threadCursor: String, $reviewCursor: String) {
  repository(owner: $owner, name: $repo) {
    pullRequest(number: $pr) {
      reviews(first: 100, after: $reviewCursor) {
        pageInfo {
          hasNextPage
          endCursor
        }
        nodes {
          databaseId
          author { login }
          body
          state
          createdAt
        }
      }
      reviewThreads(first: 100, after: $threadCursor) {
        pageInfo {
          hasNextPage
          endCursor
        }
        nodes {
          isResolved
          comments(first: 100) {
            nodes {
              databaseId
              author { login }
              body
              createdAt
              path
              line
              originalLine
              diffHunk
              replyTo { databaseId }
              pullRequestReview { databaseId }
            }
          }
        }
      }
    }
  }
}'

  local all_threads="[]"
  local all_reviews="[]"
  local thread_cursor=""
  local review_cursor=""
  local thread_has_next="true"
  local review_has_next="true"

  # Fetch all pages
  while [[ "$thread_has_next" == "true" ]] || [[ "$review_has_next" == "true" ]]; do
    local result
    local args=(-f query="$query" -F owner="$owner" -F repo="$repo" -F pr="$pr_number")
    [[ -n "$thread_cursor" ]] && args+=(-f threadCursor="$thread_cursor")
    [[ -n "$review_cursor" ]] && args+=(-f reviewCursor="$review_cursor")

    result=$(gh api graphql "${args[@]}")

    if [[ "$thread_has_next" == "true" ]]; then
      local threads
      threads=$(echo "$result" | jq '.data.repository.pullRequest.reviewThreads.nodes // []')
      all_threads=$(echo "$all_threads $threads" | jq -s 'add')
      thread_has_next=$(echo "$result" | jq -r '.data.repository.pullRequest.reviewThreads.pageInfo.hasNextPage')
      thread_cursor=$(echo "$result" | jq -r '.data.repository.pullRequest.reviewThreads.pageInfo.endCursor')
    fi

    if [[ "$review_has_next" == "true" ]]; then
      local reviews
      reviews=$(echo "$result" | jq '.data.repository.pullRequest.reviews.nodes // []')
      all_reviews=$(echo "$all_reviews $reviews" | jq -s 'add')
      review_has_next=$(echo "$result" | jq -r '.data.repository.pullRequest.reviews.pageInfo.hasNextPage')
      review_cursor=$(echo "$result" | jq -r '.data.repository.pullRequest.reviews.pageInfo.endCursor')
    fi
  done

  # Filter threads by resolved status if needed
  if [[ "$include_resolved" == "false" ]]; then
    all_threads=$(echo "$all_threads" | jq '[.[] | select(.isResolved == false)]')
  fi

  # Filter reviews with non-empty body
  all_reviews=$(echo "$all_reviews" | jq '[.[] | select(.body != "")]')

  # Return both as JSON object
  jq -n --argjson threads "$all_threads" --argjson reviews "$all_reviews" \
    '{threads: $threads, reviews: $reviews}'
}

format_thread() {
  local thread="$1"

  local comments is_resolved
  comments=$(echo "$thread" | jq -c '.comments.nodes')
  is_resolved=$(echo "$thread" | jq -r '.isResolved')

  # Get root comment (no replyTo)
  local root_comment
  root_comment=$(echo "$comments" | jq -c '[.[] | select(.replyTo == null)] | .[0]')

  if [[ "$root_comment" != "null" ]]; then
    print_comment "$root_comment" "" "false" "$is_resolved"

    local root_id
    root_id=$(echo "$root_comment" | jq -r '.databaseId')

    # Find and print replies
    echo "$comments" | jq -c --argjson parent_id "$root_id" '[.[] | select(.replyTo.databaseId == $parent_id)] | sort_by(.createdAt) | .[]' 2> /dev/null | while read -r reply; do
      print_comment "$reply" "  " "true" "$is_resolved"
    done
  fi
}

format_review_with_threads() {
  local review="$1"
  local threads_json="$2"

  local review_id body
  review_id=$(echo "$review" | jq -r '.databaseId')
  body=$(echo "$review" | jq -r '.body')

  # Print review header and body (if body is not empty)
  if [[ -n "$body" && "$body" != "" ]]; then
    print_review "$review"
  fi

  # Find threads belonging to this review
  local review_threads
  review_threads=$(echo "$threads_json" | jq -c --argjson rid "$review_id" \
    '[.[] | select(.comments.nodes[0].pullRequestReview.databaseId == $rid)]')

  # Print threads for this review
  echo "$review_threads" | jq -c '.[]' 2> /dev/null | while read -r thread; do
    format_thread "$thread"
  done
}

truncate_text() {
  local text="$1"
  local max_length="${2:-80}"
  local first_line
  first_line=$(echo "$text" | head -n 1 | sed 's/^[[:space:]]*//')
  if [[ ${#first_line} -gt $max_length ]]; then
    echo "${first_line:0:$max_length}..."
  else
    echo "$first_line"
  fi
}

format_summary() {
  local reviews_json="$1"
  local threads_json="$2"

  local review_index=0

  echo "$reviews_json" | jq -c 'sort_by(.createdAt) | .[]' | while read -r review; do
    review_index=$((review_index + 1))

    local review_id author state body
    review_id=$(echo "$review" | jq -r '.databaseId')
    author=$(echo "$review" | jq -r '.author.login // "unknown"')
    state=$(echo "$review" | jq -r '.state')
    body=$(echo "$review" | jq -r '.body')

    # Find threads belonging to this review
    local review_threads thread_count
    review_threads=$(echo "$threads_json" | jq -c --argjson rid "$review_id" \
      '[.[] | select(.comments.nodes[0].pullRequestReview.databaseId == $rid)]')
    thread_count=$(echo "$review_threads" | jq 'length')

    # Count unresolved threads
    local unresolved_count
    unresolved_count=$(echo "$review_threads" | jq '[.[] | select(.isResolved == false)] | length')

    # Format state
    local state_text
    case "$state" in
      APPROVED) state_text="approved" ;;
      CHANGES_REQUESTED) state_text="changes_requested" ;;
      COMMENTED) state_text="commented" ;;
      DISMISSED) state_text="dismissed" ;;
      *) state_text="$state" ;;
    esac

    # Print review summary line
    local thread_info=""
    if [[ "$thread_count" -gt 0 ]]; then
      thread_info=" - ${unresolved_count}/${thread_count} unresolved"
    fi
    printf '[%d] @%s (%s)%s\n' "$review_index" "$author" "$state_text" "$thread_info"

    # Print body preview if exists
    if [[ -n "$body" && "$body" != "" ]]; then
      local body_preview
      body_preview=$(truncate_text "$body" 70)
      printf '    "%s"\n' "$body_preview"
    fi

    # Print thread summaries
    echo "$review_threads" | jq -c '.[]' 2> /dev/null | while read -r thread; do
      local path is_resolved comment_count root_body root_author
      local root_comment

      root_comment=$(echo "$thread" | jq -c '.comments.nodes | [.[] | select(.replyTo == null)] | .[0]')
      path=$(echo "$root_comment" | jq -r '.path')
      line=$(echo "$root_comment" | jq -r '.line // .originalLine // "?"')
      root_author=$(echo "$root_comment" | jq -r '.author.login // "unknown"')
      root_body=$(echo "$root_comment" | jq -r '.body')
      is_resolved=$(echo "$thread" | jq -r '.isResolved')
      comment_count=$(echo "$thread" | jq '.comments.nodes | length')

      local resolved_mark=""
      if [[ "$is_resolved" == "true" ]]; then
        resolved_mark=" [resolved]"
      fi

      local body_preview
      body_preview=$(truncate_text "$root_body" 50)
      printf '    - %s:%s (%d comments)%s\n' "$path" "$line" "$comment_count" "$resolved_mark"
      printf '      @%s: "%s"\n' "$root_author" "$body_preview"
    done

    echo ""
  done
}

main() {
  local repo=""
  local pr_number=""
  local include_resolved="false"
  local show_review=""
  local full_mode="false"
  export OPEN_DETAILS="false"

  while [[ $# -gt 0 ]]; do
    case "$1" in
      -h | --help)
        show_help
        exit 0
        ;;
      -R)
        [[ $# -ge 2 ]] || die "-R requires a repository argument"
        repo="$2"
        shift 2
        ;;
      -a | --all)
        include_resolved="true"
        shift
        ;;
      -r | --review)
        [[ $# -ge 2 ]] || die "--review requires a number argument"
        show_review="$2"
        shift 2
        ;;
      -f | --full)
        full_mode="true"
        shift
        ;;
      -d | --open-details)
        OPEN_DETAILS="true"
        shift
        ;;
      -*)
        die "Unknown option: $1"
        ;;
      *)
        if [[ -z "$pr_number" ]]; then
          pr_number="$1"
        else
          die "Unexpected argument: $1"
        fi
        shift
        ;;
    esac
  done

  [[ -n "$pr_number" ]] || die "PR number is required"

  repo=$(get_repo_from_arg_or_current "$repo")
  local owner repo_name
  owner=$(echo "$repo" | cut -d'/' -f1)
  repo_name=$(echo "$repo" | cut -d'/' -f2)

  # Fetch PR data using GraphQL
  local pr_data
  pr_data=$(fetch_pr_data "$owner" "$repo_name" "$pr_number" "$include_resolved")

  local reviews threads
  reviews=$(echo "$pr_data" | jq '.reviews')
  threads=$(echo "$pr_data" | jq '.threads')

  local review_count thread_count
  review_count=$(echo "$reviews" | jq 'length')
  thread_count=$(echo "$threads" | jq 'length')

  if [[ "$review_count" == "0" && "$thread_count" == "0" ]]; then
    echo "No review comments found."
    exit 0
  fi

  # Collect all review IDs
  local review_ids
  review_ids=$(echo "$reviews" | jq '[.[].databaseId]')

  # Find orphan threads (not associated with any review)
  local orphan_threads
  orphan_threads=$(echo "$threads" | jq -c --argjson rids "$review_ids" \
    '[.[] | select(.comments.nodes[0].pullRequestReview.databaseId as $tid | $rids | index($tid) | not)]')

  # Show specific review details
  if [[ -n "$show_review" ]]; then
    local target_review
    target_review=$(echo "$reviews" | jq -c --argjson idx "$show_review" 'sort_by(.createdAt) | .[$idx - 1]')

    if [[ "$target_review" == "null" ]]; then
      die "Review [$show_review] not found. Run without --review to see available reviews."
    fi

    format_review_with_threads "$target_review" "$threads"
    exit 0
  fi

  # Full mode: show all details (original behavior)
  if [[ "$full_mode" == "true" ]]; then
    echo "$reviews" | jq -c 'sort_by(.createdAt) | .[]' | while read -r review; do
      format_review_with_threads "$review" "$threads"
    done

    local orphan_count
    orphan_count=$(echo "$orphan_threads" | jq 'length')

    if [[ "$orphan_count" -gt 0 ]]; then
      echo "$orphan_threads" | jq -c '.[]' | while read -r thread; do
        format_thread "$thread"
      done
    fi
    exit 0
  fi

  # Default: summary mode
  format_summary "$reviews" "$threads"

  # Show orphan threads summary
  local orphan_count
  orphan_count=$(echo "$orphan_threads" | jq 'length')

  if [[ "$orphan_count" -gt 0 ]]; then
    echo "Orphan threads (not associated with a review): $orphan_count"
    echo "$orphan_threads" | jq -c '.[]' 2> /dev/null | while read -r thread; do
      local path root_comment root_author root_body is_resolved comment_count
      root_comment=$(echo "$thread" | jq -c '.comments.nodes | [.[] | select(.replyTo == null)] | .[0]')
      path=$(echo "$root_comment" | jq -r '.path')
      line=$(echo "$root_comment" | jq -r '.line // .originalLine // "?"')
      root_author=$(echo "$root_comment" | jq -r '.author.login // "unknown"')
      root_body=$(echo "$root_comment" | jq -r '.body')
      is_resolved=$(echo "$thread" | jq -r '.isResolved')
      comment_count=$(echo "$thread" | jq '.comments.nodes | length')

      local resolved_mark=""
      if [[ "$is_resolved" == "true" ]]; then
        resolved_mark=" [resolved]"
      fi

      local body_preview
      body_preview=$(truncate_text "$root_body" 50)
      printf '  - %s:%s (%d comments)%s\n' "$path" "$line" "$comment_count" "$resolved_mark"
      printf '    @%s: "%s"\n' "$root_author" "$body_preview"
    done
  fi
}

main "$@"
