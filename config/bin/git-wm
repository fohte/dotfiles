#!/bin/bash
#
# git wm - Git worktree manager
#
set -euo pipefail

usage() {
  cat << EOF
Usage: git wm <command> [options]

Commands:
  new [options] [--from <base-branch>] [<name>]
      Create a new Git worktree for a branch

      Options:
        -h, --help        Show this help message
        --from <branch>   Base branch for new branch creation (default: origin/main or origin/master)
        --force           Force create new branch even if it already exists

      Arguments:
        <name>            Branch name (existing branch will be checked out,
                          non-existing branch will be created with fohte/ prefix)

  delete [options] [<worktree>]
      Delete a Git worktree and its branch

      Options:
        -h, --help        Show this help message
        -f, --force       Force delete without confirmation even if not merged

      Arguments:
        <worktree>        Worktree path or name (default: current directory)

EOF
  exit 1
}

# Function to check if branch exists
branch_exists() {
  local branch="$1"
  # Check local branch
  if git show-ref --verify --quiet "refs/heads/$branch"; then
    return 0
  fi
  # Check remote branch (with origin/ prefix)
  if git show-ref --verify --quiet "refs/remotes/origin/$branch"; then
    return 0
  fi
  # Check remote branch (as-is, in case it already has remote prefix)
  if git show-ref --verify --quiet "refs/remotes/$branch"; then
    return 0
  fi
  return 1
}

cmd_new() {
  local from_branch=""
  local force_create=false
  local name=""

  while (($#)); do
    case "$1" in
      -h | --help)
        usage
        ;;
      --from)
        [ $# -ge 2 ] || usage
        from_branch="$2"
        shift 2
        ;;
      --force)
        force_create=true
        shift
        ;;
      -*)
        echo "Unknown option: $1" >&2
        usage
        ;;
      *)
        # First non-option is treated as worktree name input
        name="$1"
        shift
        ;;
    esac
  done

  # Determine worktree directory name from branch name
  # remove fohte/ prefix to avoid fohte/fohte/<name>
  name_no_prefix="${name#fohte/}"
  # replace slashes with dashes
  worktree_name="${name_no_prefix//\//-}"
  worktree_dir="$(git root -r)/.worktrees/${worktree_name}"

  git fetch -p

  # Determine action based on branch existence and flags
  if [ "$force_create" = true ]; then
    # Force create new branch with fohte/ prefix
    base_branch="${from_branch:-origin/$(git main)}"
    branch="fohte/${name_no_prefix}"
    git worktree add "$worktree_dir" -B "$branch" "$base_branch"
  elif branch_exists "$name"; then
    # Branch exists with the exact name provided
    # If local branch exists, use it as-is
    if git show-ref --verify --quiet "refs/heads/$name"; then
      git worktree add "$worktree_dir" "$name"
    # If remote branch exists, create local tracking branch
    elif git show-ref --verify --quiet "refs/remotes/origin/$name"; then
      git worktree add "$worktree_dir" -b "$name" "origin/$name"
    else
      # Fallback: use as-is
      git worktree add "$worktree_dir" "$name"
    fi
  elif branch_exists "fohte/${name_no_prefix}"; then
    # Branch exists with fohte/ prefix
    branch="fohte/${name_no_prefix}"
    if git show-ref --verify --quiet "refs/heads/$branch"; then
      git worktree add "$worktree_dir" "$branch"
    elif git show-ref --verify --quiet "refs/remotes/origin/$branch"; then
      git worktree add "$worktree_dir" -b "$branch" "origin/$branch"
    else
      git worktree add "$worktree_dir" "$branch"
    fi
  else
    # Branch doesn't exist, create new one with fohte/ prefix
    base_branch="${from_branch:-origin/$(git main)}"
    branch="fohte/${name_no_prefix}"
    git worktree add "$worktree_dir" -b "$branch" "$base_branch"
  fi

  # create a tmux window in the current session with split layout
  # left pane: neovim, right pane: claude code
  tmux new-window -c "${worktree_dir}" -n "${worktree_name}" \; \
    split-window -h -c "${worktree_dir}" \; \
    select-pane -t 1 \; \
    send-keys "nvim" C-m \; \
    select-pane -t 2 \; \
    send-keys "claude" C-m \; \
    select-pane -t 1
}

cmd_delete() {
  local worktree_path=""
  local force_delete=false

  while (($#)); do
    case "$1" in
      -h | --help)
        usage
        ;;
      -f | --force)
        force_delete=true
        shift
        ;;
      -*)
        echo "Unknown option: $1" >&2
        usage
        ;;
      *)
        worktree_path="$1"
        shift
        ;;
    esac
  done

  # If no worktree specified, use current directory
  if [ -z "$worktree_path" ]; then
    worktree_path="$(pwd)"
  fi

  # Resolve to absolute path
  worktree_path="$(cd "$worktree_path" 2> /dev/null && pwd)" || {
    echo "Error: Invalid worktree path: $worktree_path" >&2
    exit 1
  }

  # Verify this is actually a worktree
  if ! git worktree list | grep -q "$worktree_path"; then
    echo "Error: Not a valid worktree: $worktree_path" >&2
    exit 1
  fi

  # Get the branch name associated with this worktree
  local branch_name=""
  branch_name="$(git worktree list --porcelain | grep -A 3 "^worktree $worktree_path$" | grep "^branch " | sed 's/^branch //' | sed 's|^refs/heads/||')"

  # Check if we're in a tmux session and current pane is in the worktree
  local should_close_window=false
  if [ -n "${TMUX:-}" ]; then
    current_pane_path="$(tmux display-message -p '#{pane_current_path}')"
    if [[ "$current_pane_path" == "$worktree_path"* ]]; then
      should_close_window=true
    fi
  fi

  # Check if the branch can be safely deleted before deleting worktree
  if [ -n "$branch_name" ]; then
    if git show-ref --verify --quiet "refs/heads/$branch_name"; then
      local base_branch="origin/$(git main)"

      # Check if branch is merged into base branch using git merge-base --is-ancestor
      # Note: This only detects regular merges, not squash merges
      # (squash merge detection is not reliably possible with git alone)
      if ! git merge-base --is-ancestor "$branch_name" "$base_branch" 2> /dev/null; then
        if [ "$force_delete" = false ]; then
          echo "Warning: Branch '$branch_name' is not fully merged into $base_branch" >&2
          echo "Note: Squash-merged branches cannot be automatically detected" >&2
          read -p "Delete anyway? [y/N] " -n 1 -r
          echo
          if [[ ! $REPLY =~ ^[Yy]$ ]]; then
            echo "Cancelled."
            exit 0
          fi
        fi
      fi
    fi
  fi

  # Remove the worktree
  git worktree remove "$worktree_path"
  echo "Worktree removed: $worktree_path"

  # Delete the branch if it exists
  if [ -n "$branch_name" ]; then
    if git show-ref --verify --quiet "refs/heads/$branch_name"; then
      git branch -D "$branch_name"
      echo "Branch deleted: $branch_name"
    fi
  fi

  # Close tmux window if we're in it
  if [ "$should_close_window" = true ]; then
    tmux kill-window
  fi
}

# Main command dispatcher
case "${1:-}" in
  new)
    shift
    cmd_new "$@"
    ;;
  delete)
    shift
    cmd_delete "$@"
    ;;
  -h | --help)
    usage
    ;;
  *)
    echo "Error: Unknown command: ${1:-}" >&2
    usage
    ;;
esac
