#!/usr/bin/env bash
#
# vibe - Claude Code wrapper with tmux session and git worktree management
#
# Requirements:
#   - tmux
#   - git
#   - claude (Claude Code CLI)
#
# Usage:
#   vibe start <name>
#   vibe done <name> [--force]
#
set -euo pipefail

usage() {
  cat << EOF
Usage: $(basename "$0") <command> [<args>]

Commands:
  start <name>
    Start a new Claude Code session with worktree

  done <name> [--force]
    Remove branch and worktree (only if merged)
    Use --force to skip merge check

vibe is a wrapper for Claude Code that:
  - Creates/enters a tmux session 'vibe'
  - Creates a git branch 'claude/<name>' from origin/master
  - Creates a worktree at '.worktrees/<name>'
  - Starts Claude Code in a new tmux window
EOF
}

# Helper functions
error_exit() {
  echo "error: $1" >&2
  exit 1
}

error_usage() {
  echo "error: $1" >&2
  usage
  exit 1
}

verify_git_repo() {
  git rev-parse --git-dir > /dev/null 2>&1 || error_exit "not in a git repository"
}

check_branch_exists() {
  local branch="$1"
  git show-ref --verify --quiet "refs/heads/${branch}"
}

is_branch_merged() {
  local branch="$1"
  git branch --merged | grep -q "^[[:space:]]*${branch}$"
}

check_pr_merged() {
  local branch="$1"
  command -v gh &> /dev/null || return 1

  local pr_info
  pr_info=$(gh pr list --state all --head "${branch}" --json number,merged,state --limit 1 2> /dev/null)

  [[ -n "$pr_info" && "$pr_info" != "[]" ]] || return 1
  echo "$pr_info" | jq -e '.[0].merged == true' > /dev/null 2>&1
}

tmux_session_exists() {
  local session="$1"
  tmux has-session -t "$session" 2> /dev/null
}

tmux_window_exists() {
  local session="$1"
  local window="$2"
  tmux list-windows -t "$session" -F "#{window_name}" 2> /dev/null | grep -q "^${window}$"
}

create_branch_from_origin() {
  local branch="$1"
  echo "Creating branch '${branch}' from origin/master..."
  git fetch origin master
  git branch "${branch}" origin/master
}

create_worktree() {
  local path="$1"
  local branch="$2"
  echo "Creating worktree at '${path}'..."
  git worktree add "${path}" "${branch}"
}

start_claude_in_tmux() {
  local session="$1"
  local window="$2"
  local worktree_path="$3"
  local create_new_session="$4"

  if [[ "$create_new_session" == "true" ]]; then
    tmux new-session -ds "$session" -n "$window" -c "${worktree_path}"
  else
    tmux new-window -t "$session" -n "$window" -c "${worktree_path}"
  fi

  tmux send-keys -t "$session:$window" "claude" C-m
  tmux switch-client -t "$session" 2> /dev/null || true
}

# Main script
[[ "$#" -lt 1 ]] && error_usage "missing command"

command="$1"
shift

# Parse command and arguments
parse_start_command() {
  [[ "$#" -ne 1 ]] && error_usage "'start' requires exactly one argument"
  echo "$1"
}

parse_done_command() {
  local force=false
  local name=""

  while [[ "$#" -gt 0 ]]; do
    case "$1" in
      --force)
        force=true
        shift
        ;;
      -*)
        error_usage "unknown option '$1'"
        ;;
      *)
        [[ -n "$name" ]] && error_usage "'done' requires exactly one name argument"
        name="$1"
        shift
        ;;
    esac
  done

  [[ -z "$name" ]] && error_usage "'done' requires a name argument"
  echo "$name $force"
}

# Command implementations
handle_start() {
  local branch="$1"
  local worktree_path="$2"
  local worktree_dir="$3"

  # Check prerequisites
  check_branch_exists "${branch}" && error_exit "Branch '${branch}' already exists"
  [[ -d "${worktree_path}" ]] && error_exit "Worktree '${worktree_dir}' already exists"

  # Create branch and worktree
  create_branch_from_origin "${branch}"
  create_worktree "${worktree_path}" "${branch}"

  # Setup tmux
  local create_new_session=false
  tmux_session_exists "$SESSION_NAME" || create_new_session=true

  local window_name="$(basename "${git_root}")-${name}"
  start_claude_in_tmux "$SESSION_NAME" "$window_name" "${worktree_path}" "$create_new_session"
}

verify_branch_merged() {
  local branch="$1"
  local force="$2"

  [[ "$force" == "true" ]] && echo "Force deletion requested, skipping merge check..." && return 0

  # Try GitHub PR first (handles squash merge)
  check_pr_merged "${branch}" && return 0

  # Fall back to git branch --merged
  is_branch_merged "${branch}" && return 0

  error_exit "branch '${branch}' has not been merged yet\nPlease merge the branch first or use 'vibe done ${name} --force' to force delete"
}

remove_worktree() {
  local worktree_path="$1"
  local worktree_dir="$2"

  [[ ! -d "${worktree_path}" ]] && return 0

  echo "Removing worktree at '${worktree_dir}'..."
  git worktree remove "${worktree_path}"
}

delete_branch() {
  local branch="$1"
  local force="$2"

  echo "Deleting branch '${branch}'..."
  if [[ "$force" == "true" ]]; then
    git branch -D "${branch}"
  else
    git branch -d "${branch}"
  fi
}

close_tmux_window() {
  local session="$1"
  local window="$2"

  tmux_window_exists "$session" "$window" || return 0

  echo "Closing tmux window '${window}'..."
  tmux kill-window -t "$session:${window}"
}

handle_done() {
  local branch="$1"
  local worktree_path="$2"
  local worktree_dir="$3"
  local force="$4"

  # Verify branch exists
  check_branch_exists "${branch}" || error_exit "Branch '${branch}' does not exist"

  # Verify branch is merged (unless forced)
  verify_branch_merged "${branch}" "${force}"

  # Clean up resources
  remove_worktree "${worktree_path}" "${worktree_dir}"
  delete_branch "${branch}" "${force}"

  local window_name="$(basename "${git_root}")-${name}"
  close_tmux_window "$SESSION_NAME" "${window_name}"

  echo "Done! Branch '${branch}' and worktree '${worktree_dir}' have been removed."
}

# Main execution
# Verify prerequisites
verify_git_repo

# Get the git root directory
git_root="$(git rev-parse --show-toplevel)"

SESSION_NAME="vibe"
branch="claude/${name}"
worktree_dir=".worktrees/${name}"
worktree_path="${git_root}/${worktree_dir}"

# Parse command and get name
case "$command" in
  start)
    name=$(parse_start_command "$@")
    handle_start "${branch}" "${worktree_path}" "${worktree_dir}"
    ;;
  done)
    read -r name force <<< "$(parse_done_command "$@")"
    handle_done "${branch}" "${worktree_path}" "${worktree_dir}" "${force}"
    ;;
  *)
    error_usage "unknown command '$command'"
    ;;
esac
