#!/usr/bin/env bash
#
# vibe - Claude Code wrapper with tmux session and git worktree management
#
# Requirements:
#   - tmux
#   - git
#   - claude (Claude Code CLI)
#
# Usage:
#   vibe start <name>
#   vibe done [<name>] [--force|-f]
#
set -euo pipefail

# Get the directory where this script is located
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
LIB_DIR="${SCRIPT_DIR}/lib/vibe"

# Common utility functions
error_exit() {
  echo -e "error: $1" >&2
  exit 1
}

error_usage() {
  echo "error: $1" >&2
  usage
  exit 1
}

usage() {
  cat << EOF
Usage: $(basename "$0") [--debug] [-R|--repo <path>] <command> [<args>]

Global Options:
  --debug           Enable debug output
  -R, --repo <name> Specify repository by name (e.g., dotfiles, fohte/dotfiles)

Commands:
  start <name>
    Start a new Claude Code session with worktree

  done [<name>] [--force|-f]
    Remove branch and worktree (only if merged)
    If <name> is omitted, uses current window name in vibe session
    Use --force or -f to skip merge check

vibe is a wrapper for Claude Code that:
  - Creates/enters a tmux session 'vibe'
  - Creates a git branch 'claude/<name>' from origin/master
  - Creates a worktree at '.worktrees/<name>'
  - Starts Claude Code in a new tmux window
EOF
}

# Source library files
# SC1091: Disable "Not following" warning for dynamic source paths
# These files are sourced at runtime using variables, making static analysis difficult
# See: https://github.com/koalaman/shellcheck/issues/2176
# shellcheck disable=SC1091
source "${LIB_DIR}/git.bash"
# shellcheck disable=SC1091
source "${LIB_DIR}/tmux.bash"
# shellcheck disable=SC1091
source "${LIB_DIR}/command_start.bash"
# shellcheck disable=SC1091
source "${LIB_DIR}/command_done.bash"

# Debug function
debug() {
  if [[ "${VIBE_DEBUG:-}" == "1" ]]; then
    echo "DEBUG: $*" >&2
  fi
}

# Resolve repository name to path using ghq
resolve_repo_path() {
  local repo_name="$1"
  local ghq_root
  ghq_root="$(ghq root)" || error_exit "ghq is not available or configured"

  # Get all matching repositories
  local matches
  matches=$(ghq list | grep -E "(^|/)${repo_name}$" || true)

  if [[ -z "$matches" ]]; then
    error_exit "repository '${repo_name}' not found in ghq repositories"
  fi

  # If multiple matches, show them and exit
  local match_count
  match_count=$(echo "$matches" | wc -l | tr -d ' ')
  if [[ "$match_count" -gt 1 ]]; then
    echo "error: multiple repositories match '${repo_name}':" >&2
    while IFS= read -r match; do
      echo "  $match" >&2
    done <<< "$matches"
    echo "Please specify a more specific name." >&2
    exit 1
  fi

  local repo_path="${ghq_root}/${matches}"
  debug "Resolved '${repo_name}' to '${repo_path}'"
  echo "$repo_path"
}

# Parse global options
VIBE_DEBUG=0
VIBE_REPO_PATH=""
while [[ "$#" -gt 0 ]]; do
  case "$1" in
    --debug)
      VIBE_DEBUG=1
      shift
      ;;
    -R | --repo)
      [[ "$#" -lt 2 ]] && error_usage "option '$1' requires an argument"
      VIBE_REPO_PATH="$2"
      shift 2
      ;;
    -*)
      break
      ;;
    *)
      break
      ;;
  esac
done

# Main script
[[ "$#" -lt 1 ]] && error_usage "missing command"

command="$1"
shift

# Main execution
# Change to specified repo directory if provided
if [[ -n "${VIBE_REPO_PATH}" ]]; then
  resolved_path=$(resolve_repo_path "${VIBE_REPO_PATH}")
  [[ ! -d "${resolved_path}" ]] && error_exit "repository path '${resolved_path}' does not exist"
  cd "${resolved_path}" || error_exit "failed to change to repository path '${resolved_path}'"
fi

# Verify prerequisites
verify_git_repo

# Get the main git directory (not worktree)
git_common_dir="$(git rev-parse --git-common-dir)"
git_root="$(dirname "${git_common_dir}")"
project_name="$(basename "${git_root}")"

SESSION_NAME="vibe"

# Parse command and get name
case "$command" in
  start)
    name=$(parse_start_command "$@")
    branch="claude/${name}"
    worktree_dir=".worktrees/${name}"
    worktree_path="${git_root}/${worktree_dir}"
    handle_start "${branch}" "${worktree_path}" "${worktree_dir}" "${SESSION_NAME}" "${project_name}"
    ;;
  done)
    parsed_output=$(parse_done_command "$@") || exit 1
    read -r name force from_current_window <<< "$parsed_output"
    branch="claude/${name}"
    worktree_dir=".worktrees/${name}"
    worktree_path="${git_root}/${worktree_dir}"
    handle_done "${branch}" "${worktree_path}" "${worktree_dir}" "${force}" "${SESSION_NAME}" "${project_name}" "${git_root}" "${from_current_window}"
    ;;
  *)
    error_usage "unknown command '$command'"
    ;;
esac
